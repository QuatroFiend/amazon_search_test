# Engineering Notes

## Выбор технологий 

**Next.js 16 (App Router) + React Server Components**

**Обоснование выбора:**
- **All-in-one фреймворк**: Next.js предоставляет полную инфраструктуру для создания production-ready приложений без дополнительных инструментов - роутинг, SSR, API routes и оптимизация деплоя из коробки
- **Нативное управление URL state**: Встроенный `searchParams` API устраняет необходимость в сторонних библиотеках управления состоянием (Redux, Zustand) для синхронизации фильтров и поиска
- **SEO-first архитектура**: E-commerce требует индексации поисковыми системами. Server Components рендерят каталог продуктов на сервере, делая контент мгновенно доступным для Google ботов без ожидания гидратации JavaScript на клиенте
- **Производительность**: SSR обеспечивает быстрый Time-to-First-Byte (TTFB) и First Contentful Paint (FCP) - критичные метрики для конверсии в e-commerce

**Компромисс:**
- Полная перезагрузка страницы при изменении фильтров (в отличие от клиентской фильтрации в SPA)
- SEO, shareable URLs и простая архитектура важнее мгновенных переходов для MVP

---

**TypeScript**

**Обоснование выбора:**
- Сквозная типобезопасность по всему data pipeline: `Схема БД → API responses → UI компоненты`
- Ловит ошибки на этапе компиляции (например, опечатки в именах полей фильтров, неверные типы данных из Supabase)
- Улучшенный developer experience с автокомплитом и inline документацией

---

**Module CSS вместо Tailwind CSS**

**Решение:** Использовать CSS Modules для стилизации вместо utility-first фреймворка

**Обоснование выбора:**
- **Чистота кода**: Разделяет логику стилизации и JSX разметки - компоненты остаются читаемыми и сфокусированными на поведении
- **Изолированные стили**: CSS Modules автоматически делают scope для имён классов, предотвращая коллизии стилей без необходимости соблюдать naming conventions (BEM и т.д.)
- **Соответствие масштабу проекта**: Для одностраничного приложения с ~10-15 компонентами конфигурационный overhead Tailwind и многословность utility классов не оправданы

**Когда Tailwind имел бы смысл:**
- Большая дизайн-система с десятками переиспользуемых компонентов
- Необходимость быстрого прототипирования с предопределёнными design tokens
- Команда уже знакома с соглашениями Tailwind

**Компромисс:**
-  Нет встроенных responsive utilities (нужно писать media queries вручную)
-  Дольше писать кастомные стили в сравнении с Tailwind классами
-  Более чистый код компонентов, легче читать при code review
-  Не нужен конфигурационный файл, нет настройки purge

**Путь миграции:** Если проект вырастет за рамки MVP, переход на Tailwind потребует ~2-3 часа рефакторинга (CSS Modules могут сосуществовать с Tailwind во время перехода) 

## Ключевые архитектурные решения.

### 1. Server-Side Faceted Search

**Решение:** Фасетный поиск сделал серверным (Server Components), а URL оставил источником правды для фильтров и поиска.

**Почему так:**
- `searchParams` закрывает сразу несколько задач: shareable links, воспроизводимость состояния, простая отладка.
- SEO не проседает: каталог и результаты фильтрации рендерятся на сервере.
- Не нужен отдельный state-manager ради синхронизации `URL ↔ UI`.

**Почему не client-only фильтрация:**
- Нужно тянуть большой объём данных на клиент и держать его в памяти.
- На слабых устройствах это быстро превращается в лаги.
- Сложнее поддерживать консистентность состояния.

**Компромисс:**
-  Навигация по фильтрам не мгновенная (как в SPA).
-  Решение предсказуемое, SEO-friendly и легко поддерживать.

---

**Техническое решение: ID-based URL encoding вместо name-based**

Изначально фильтры были name-based, но в итоге перевёл на ID:
```
?brands=1,2,5&categories=3,7
```

**Почему:**
- ID стабильнее (rename бренда не ломает ссылку).
- Нет проблем с коллизиями названий и URL encoding.
- Парсинг и валидация проще: только положительные integer значения.

**Компромисс:**
-  URL менее “человеческий”.
-  Для MVP надёжность и предсказуемость важнее.

**Как улучшил бы в production:**
- Добавил бы `slug` в БД и перешёл на гибрид `slug-id` для читабельности + стабильности.

---

### 2. Динамические Facet Counts с селективным исключением фильтров

**Решение:** При расчёте counts исключаю “собственный” тип фильтра:
- для брендов не применяю `brandIds`, но применяю `categoryIds` и `q`;
- для категорий наоборот.

**Почему так:**
- Пользователь видит потенциал фильтра, а не набор нулей.
- Это лучше для discoverability при 2 фасетах в MVP.

**Текущая реализация:**
- Counts считаются в приложении через выборку + `reduce`.
- Для 10k товаров performance достаточный. При росте до 100k+ — агрегация переедет в SQL (`GROUP BY`, RPC/view) с индексами.

**Оптимизация, которую уже сделал:**
- counts и товары запрашиваются параллельно, чтобы не ждать их последовательно.

---

### 3. Обработка Edge Cases для пагинации

**Решение:** Любой невалидный `page` привожу к валидному значению и делаю редирект с сохранением фильтров.

**Что закрывает:**
- `page <= 0`, дробные значения, слишком большие номера страницы.
- Устаревшие ссылки, которые могут прилететь извне.

**Почему это важно:**
- Пользователь не упирается в “битое” состояние.
- URL остаётся консистентным и шарится без сюрпризов.

---

### 4. Partial Text Search (ILIKE)

**Решение:** Частичный поиск сделал через `ILIKE %query%`.

**Почему так:**
- Самая простая и понятная реализация под MVP.
- Даёт ожидаемое поведение “по части слова”.

**Trade-off:**
-  На объёмах >100k `ILIKE` требует оптимизации.
-  Для 10k товаров performance приемлемый, задача решена корректно.

**План на scale:**
- `pg_trgm`/Full-Text Search + GIN индекс.
- Отдельно добавить autocomplete и ранжирование.

---

### 5. Кастомная система сортировки с креативным подходом к "популярности"

**Решение:** Поддержал 5 сортировок: `newest`, `oldest`, `name-asc`, `name-desc`, `popular`.

**Как сделал `popular`:**
- В БД нет готового `popularity_score`, поэтому использовал proxy:
  количество товаров у бренда + tie-break по `created_at`.

**Реализация:**
- Для `popular` загружаю весь отфильтрованный набор, сортирую в приложении, затем пагинирую.
- Для MVP это оптимальный баланс простоты и функциональности. При масштабе до 100k+ — sorting переедет на SQL level.

**План на production:**
- Вынести popular-скор в БД (материализованное поле/view) и сортировать уже на SQL уровне.
- Добавить кэш по ключу фильтров (короткий TTL), чтобы не пересчитывать одно и то же на каждый запрос.

---

### 6. Переиспользуемые UI-компоненты и масштабируемость UI

**Что сделал:**
- Собрал базовый набор переиспользуемых UI-кирпичей: `Icon`, `Typography`, `Button`, `IconButton`, `CheckBox`, `RadioButton`.
- Иконки вынес в типизированный реестр (`IconName` + единая точка рендера), чтобы добавление новых иконок не размазывалось по приложению.
- Типографику и стили текста централизовал через variant-подход (`title`, `cardTitle`, `info`, `error`, `link`), чтобы держать единый визуальный язык.

**Почему это хорошо для масштаба:**
- Новые экраны собираются из готовых блоков, а не из копипасты.
- UI меняется точечно (в одном месте), а не пачкой по всему проекту.
- Проще поддерживать консистентность и ускорять дальнейшую разработку.

---

### 7. Архитектура `app/api` и устойчивость приложения

**Архитектура `app/api`:**
- Разложил по ответственности: `products`, `brands`, `categories`.
- Внутри `products` — отдельно `helpers`, `facets`, `queries`, плюс оркестратор `productService`.
- Такой слой удобен для роста: можно добавлять новые фильтры/сортировки без переписывания всего сервиса.

**Надёжность на уровне UI/рендера:**
- Есть отдельный `loading.tsx` для состояния загрузки.
- Есть `error.tsx` для recoverable ошибок страницы (с `reset()`).
- Есть `global-error.tsx` для критичных сбоев рендера приложения.

**Зачем это важно:**
- Пользователь не остаётся на белом экране при проблемах сети/рендера.
- Есть предсказуемый fallback UX и понятный путь восстановления.

---

## Известные ограничения MVP

### UI/UX и адаптивность

**Текущее состояние:**
- UI выполнен в минималистичном стиле без полировки дизайна.
- Адаптивность для мобильных устройств и планшетов не реализована — интерфейс оптимизирован только для desktop разрешений.
- Нет продвинутых UX-паттернов (skeleton loaders, transitions, микроанимации и т.д.).

**Контекст и причины:**
- Фокус MVP был на архитектурной надёжности и функциональности бэкенда (server-side фильтрация, SEO, обработка edge cases, производительность).
- Временные ограничения требовали расставить приоритеты: стабильная логика и масштабируемая архитектура были важнее визуальной полировки.
- В результате получился рабочий proof-of-concept с надёжным фундаментом, но визуально базовым интерфейсом.

**Итог:** Текущая версия жертвует визуалом ради архитектурной прочности. Это осознанный trade-off для MVP, который позволит быстро нарастить UI-слой на стабильном фундаменте.

### Нетривиальный edge case, который закрыл

**Проблема:** race-condition в multi-select чекбоксах при быстрых кликах (часть выбора могла теряться до обновления URL).

**Решение:**
- Добавил optimistic local state для чекбоксов.
- Синхронизацию с URL сделал через controlled remount.
- Переключил фильтры на `router.replace`, чтобы не засорять browser history.

**Итог:** UI стал предсказуемее, а URL остался источником правды после навигации.

---

### Как бы масштабировал дальше

1. Перенёс бы facet counts в SQL агрегации (`GROUP BY` через RPC/view), чтобы снять нагрузку с Node.
2. Добавил бы индексы под фильтры и поиск:
   - `products(brand_id)`
   - `product_categories(product_id, category_id)` и `product_categories(category_id, product_id)`
   - `pg_trgm` индекс для поиска по `name`.
3. Ввел бы кэш для тяжёлых веток (`popular`, facet counts) с коротким TTL.
4. Добавил бы мониторинг медленных запросов и трассировку на уровне Supabase/приложения.

---



